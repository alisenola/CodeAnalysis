import sys
import os
import argparse
import csv
import re

# relevant columns in input csvs
ent1file = 0
ent2file = 10

class PathTransformer:
  def __init__ (self):
    self.codestem = ""
    self.packageindex = 0

  def setStem (self, stem):
    self.codestem = os.path.join(stem, "")
    self.packageindex = self.codestem.count("/")

  def extractRelevantPath (self, fullPath):
    if re.match(self.codestem, fullPath):
      return os.path.join(*(fullPath.split("/")[self.packageindex:]))
    else:
      return None

def extractPackage (shortPath):
  return re.match("([^/]+)/", shortPath).group(1)

def dedupdepdata (outfilename, inputs, repos, years, languages, pathstems):
  pt = PathTransformer()
  with open(outfilename, 'w') as outfile:
    writer = csv.writer(outfile, delimiter='\t', quoting=csv.QUOTE_NONE)
    for infilename, repo, year, language, pathstem in zip(inputs, repos, years, languages, pathstems):
      # update method for cutting off path stems
      pt.setStem(pathstem)

      # find deps
      print("Processing " + infilename + " for " + repo + " " + year + " " + language + " with pathstem " + pathstem)
      with open(infilename, 'r') as infile:
        reader = csv.reader(infile)
        next(reader) # ignore header
        depmap = {}
        for row in reader:
          f1 = pt.extractRelevantPath(row[ent1file])
          f2 = pt.extractRelevantPath(row[ent2file])
          if f1 and f2:
            if f1 not in depmap:
              depmap[f1] = set()
            depmap[f1].add(f2)

      # record deps
      writtenrows = 0
      for f1 in depmap:
        p1 = extractPackage(f1)
        for f2 in depmap[f1]:
          p2 = extractPackage(f2)
          writer.writerow([repo, year, language, p1, p2, f1, f2])
          writtenrows += 1
      print("Wrote " + str(writtenrows) + " rows.")

if __name__ == "__main__":
  ap = argparse.ArgumentParser(description =
    "Deduplicates dependency data csvs so that only one dependency is recorded between any two files."
    "Multiple inputs may be specified, but each must be matched with its corresponding year, language, and pathstem.")
  ap.add_argument("--output", required=True, help="The output csv file.")
  ap.add_argument("--input", required=True, action="append", help="A final csv file as generated by the Makefile.")
  ap.add_argument("--repo", required=True, action="append", choices=["ba", "tocb"], help="The repository of the corresponding input csv.")
  ap.add_argument("--year", required=True, action="append", help="The year of the corresponding input csv.")
  ap.add_argument("--language", required=True, action="append", choices=["C++", "Java"], help="The language of the corresponding input csv.")
  ap.add_argument("--pathstem", required=True, action="append", help="The common path stem shared by code files in the corresponding input csv, as a regular expression.")

  args = ap.parse_args()
  if not (len(args.input) == len(args.repo) == len(args.year) == len(args.language) == len(args.pathstem)):
    print("Error: inconsistent numbers of arguments supplied.")
    print("inputs: " + str(len(args.input)))
    print("repos: " + str(len(args.repo)))
    print("years: " + str(len(args.year)))
    print("languages: " + str(len(args.language)))
    print("pathstems: " + str(len(args.pathstem)))
    exit(1)

  dedupdepdata(args.output, args.input, args.repo, args.year, args.language, args.pathstem)

